/** 4.꿈의 설계+
원래 미래 : A를 훈련한 수치와 A를 고민한 수치를 곱하면 1000이 나옵니다. B를 훈련한 수치와 B를 고민한 수치를 곱하면 1200이 나옵니다. 이를 더하면 원래 미래가 나옵니다.
바뀐 미래 : 가장 많이 훈련한 수치에 100을 더합니다. 
            가장 많이 고민한 수치에 100을 더합니다. 따라서 B를 훈련한 수치는 130이 되고, A를 고민한 수치는 200이 됩니다. 
            최종적으로 A를 훈련한 수치는 10, A를 고민한 수치는 200이 되므로 2000 값이 되고, B를 훈련한 수치는 130에 B를 고민한 수치 40을 곱하여 5200이 됩니다.
- 입력 배열의 길이는 2입니다. [훈련수치, 고민수치]의 형태로 문자열이 입력됩니다.
- 수치 문자열은 항상 마침표 단위로 문장이 나뉩니다. 나누어진 문장을 나뉜 문장이라고 했을 때 나뉜 문장에는 항상 유일한 수치와 유일한 알파벳이 있습니다.
- 매칭되는 고민 수치와 훈련 수치가 없을 경우에는 ‘미래가 보이지 않습니다.’라고 출력해야 합니다.
- 1 ≤ 나뉜문장  ≤ 10
- 1 ≤ 수치 ≤ 1000
- A ≤ 알파벳 ≤ z
 */

const testcases = [
    ['10 - A. 20 - B. 30 - A.', '1 - A. 1 - A. 1 - A. 1 - A. 2 - B. 1 - A. 1 - B'], 
    ['10 a. 10 a. 10 a. 20 b. 30 c.', 'c -- 100, c -- 100, c -- 100'], 
    ['100만큼 a를 훈련. 200만큼 b를 훈련. 300만큼 c를 훈련. ', '100만큼 d를 훈련, 200만큼 e를 훈련']
]
const answers = [];
for (let index = 0; index < testcases.length; index++) {
    const training = testcases[index][0];
    const consider = testcases[index][1];
    const answer = '최종 꿈의 설계는 원래 미래 %d, 바뀐 미래 %d입니다. 이 수치대로 Vision을 만듭니다.';
    //훈련,고민 수치 찾기
    let tFound = training.match(/(1000)|([1-9][0-9]{0,2})|[a-zA-Z]/g);// {0,2}: [0-9]의 숫자가 최대 0에서 2번이하로 반복, 1000같은 큰 숫자 앞쪽에 작성
    let cFound = consider.match(/(1000)|([1-9][0-9]{0,2})|[a-zA-Z]/g);
    //원래 미래 찾기
    var future = [];
    

    answers.push(tFound);
}
console.log(answers);
//['최종 꿈의 설계는 원래 미래 260, 바뀐 미래 14760입니다. 이 수치대로 Vision을 만듭니다.', 
//'최종 꿈의 설계는 원래 미래 9000, 바뀐 미래 52000입니다. 이 수치대로 Vision을 만듭니다.', 
//'미래가 보이지 않습니다.']

